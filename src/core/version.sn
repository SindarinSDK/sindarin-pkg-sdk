# ==============================================================================
# sdk/core/version.sn - Semantic Versioning for Sindarin
# ==============================================================================
# Provides Version and VersionConstraint types implementing SemVer 2.0.0
# with version constraint checking inspired by npm/Cargo conventions.
#
# Usage:
#   import "sdk/core/version"
#
#   var v: Version = Version.parse("1.2.3-beta.1+build.5")
#   print($"Version: {v.toString()}\n")
#   print($"Is stable: {v.isStable()}\n")
#
#   var satisfies: bool = version_satisfies(v, "^1.0.0")
#   print($"Satisfies ^1.0.0: {satisfies}\n")
# ==============================================================================

# ==============================================================================
# Operator Constants for VersionConstraint
# ==============================================================================

fn OP_EQ(): int => 0
fn OP_GT(): int => 1
fn OP_GTE(): int => 2
fn OP_LT(): int => 3
fn OP_LTE(): int => 4
fn OP_CARET(): int => 5
fn OP_TILDE(): int => 6

# ==============================================================================
# Version Struct
# ==============================================================================

struct Version =>
    major: int = 0
    minor: int = 0
    patch: int = 0
    prerelease: str = ""
    build: str = ""

    # ==========================================================================
    # Static Methods
    # ==========================================================================

    # Parse a version string: "1.2.3", "1.2.3-beta.1", "v1.2.3-rc.1+build.5"
    static fn parse(s: str): Version =>
        var input: str = s
        # Strip optional 'v' or 'V' prefix
        if input.length > 0 =>
            var first: char = input.charAt(0)
            if first == 'v' || first == 'V' =>
                input = input.substring(1, input.length)
        return _parseVersionString(input)

    # ==========================================================================
    # Instance Methods
    # ==========================================================================

    # Format as "MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]"
    fn toString(): str =>
        var result: str = $"{self.major}.{self.minor}.{self.patch}"
        if self.prerelease != "" =>
            result = $"{result}-{self.prerelease}"
        if self.build != "" =>
            result = $"{result}+{self.build}"
        return result

    # Compare with another version following SemVer 2.0.0 precedence
    # Returns -1, 0, or 1
    fn compare(other: Version): int =>
        return _versionCmp(self.major, self.minor, self.patch, self.prerelease, other.major, other.minor, other.patch, other.prerelease)

    fn eq(other: Version): bool =>
        return self.compare(other) == 0

    fn gt(other: Version): bool =>
        return self.compare(other) == 1

    fn lt(other: Version): bool =>
        return self.compare(other) == -1

    fn gte(other: Version): bool =>
        return self.compare(other) >= 0

    fn lte(other: Version): bool =>
        return self.compare(other) <= 0

    # True if prerelease is non-empty
    fn isPrerelease(): bool =>
        return self.prerelease != ""

    # True if major > 0 and no prerelease
    fn isStable(): bool =>
        return self.major > 0 && self.prerelease == ""

    # Bump major version (resets minor, patch, prerelease, build)
    fn bumpMajor(): Version =>
        var result: Version = Version { major: self.major + 1, minor: 0, patch: 0, prerelease: "", build: "" }
        return result

    # Bump minor version (resets patch, prerelease, build)
    fn bumpMinor(): Version =>
        var result: Version = Version { major: self.major, minor: self.minor + 1, patch: 0, prerelease: "", build: "" }
        return result

    # Bump patch version (resets prerelease, build)
    fn bumpPatch(): Version =>
        var result: Version = Version { major: self.major, minor: self.minor, patch: self.patch + 1, prerelease: "", build: "" }
        return result

# ==============================================================================
# VersionConstraint Struct
# ==============================================================================

struct VersionConstraint =>
    op: int = 0
    major: int = 0
    minor: int = 0
    patch: int = 0
    prerelease: str = ""

    # ==========================================================================
    # Static Methods
    # ==========================================================================

    # Parse a constraint string: "^1.2.3", ">=1.0.0", "~0.2.3", "=1.0.0",
    # ">1.0.0", "<2.0.0", "<=1.5.0"
    static fn parse(s: str): VersionConstraint =>
        var input: str = s.trim()
        var op: int = OP_EQ()
        var versionStr: str = input

        # Detect operator prefix
        if input.startsWith(">=") =>
            op = OP_GTE()
            versionStr = input.substring(2, input.length)
        else if input.startsWith("<=") =>
            op = OP_LTE()
            versionStr = input.substring(2, input.length)
        else if input.startsWith("^") =>
            op = OP_CARET()
            versionStr = input.substring(1, input.length)
        else if input.startsWith("~") =>
            op = OP_TILDE()
            versionStr = input.substring(1, input.length)
        else if input.startsWith(">") =>
            op = OP_GT()
            versionStr = input.substring(1, input.length)
        else if input.startsWith("<") =>
            op = OP_LT()
            versionStr = input.substring(1, input.length)
        else if input.startsWith("=") =>
            op = OP_EQ()
            versionStr = input.substring(1, input.length)

        # Parse the version part
        var base: Version = _parseConstraintVersion(versionStr.trim())
        var result: VersionConstraint = VersionConstraint { op: op, major: base.major, minor: base.minor, patch: base.patch, prerelease: base.prerelease }
        return result

    # ==========================================================================
    # Instance Methods
    # ==========================================================================

    # Check if a version satisfies this constraint
    fn satisfiedBy(v: Version): bool =>
        var cmp: int = _versionCmp(v.major, v.minor, v.patch, v.prerelease, self.major, self.minor, self.patch, self.prerelease)

        if self.op == OP_EQ() =>
            return cmp == 0
        if self.op == OP_GT() =>
            return cmp == 1
        if self.op == OP_GTE() =>
            return cmp >= 0
        if self.op == OP_LT() =>
            return cmp == -1
        if self.op == OP_LTE() =>
            return cmp <= 0

        if self.op == OP_CARET() =>
            # Caret: >=version, <next major/minor/patch boundary
            if cmp == -1 =>
                return false
            if self.major != 0 =>
                # ^1.2.3 -> >=1.2.3, <2.0.0
                return _versionCmp(v.major, v.minor, v.patch, v.prerelease, self.major + 1, 0, 0, "") == -1
            if self.minor != 0 =>
                # ^0.2.3 -> >=0.2.3, <0.3.0
                return _versionCmp(v.major, v.minor, v.patch, v.prerelease, 0, self.minor + 1, 0, "") == -1
            # ^0.0.3 -> >=0.0.3, <0.0.4
            return _versionCmp(v.major, v.minor, v.patch, v.prerelease, 0, 0, self.patch + 1, "") == -1

        if self.op == OP_TILDE() =>
            # Tilde: >=version, <next minor
            # ~1.2.3 -> >=1.2.3, <1.3.0
            if cmp == -1 =>
                return false
            return _versionCmp(v.major, v.minor, v.patch, v.prerelease, self.major, self.minor + 1, 0, "") == -1

        return false

# ==============================================================================
# Helper Functions (internal, defined after structs for C type ordering)
# ==============================================================================

# Core version comparison following SemVer 2.0.0 precedence
# Returns -1, 0, or 1
fn _versionCmp(aMaj: int, aMin: int, aPat: int, aPre: str, bMaj: int, bMin: int, bPat: int, bPre: str): int =>
    if aMaj < bMaj =>
        return -1
    if aMaj > bMaj =>
        return 1
    if aMin < bMin =>
        return -1
    if aMin > bMin =>
        return 1
    if aPat < bPat =>
        return -1
    if aPat > bPat =>
        return 1
    # Version with prerelease < same version without prerelease
    if aPre != "" =>
        if bPre == "" =>
            return -1
    if aPre == "" =>
        if bPre != "" =>
            return 1
    # Compare prerelease identifiers
    return _comparePrerelease(aPre, bPre)

# Convert a numeric string to an integer via ASCII arithmetic
fn _strToInt(s: str): int =>
    var result: int = 0
    var i: int = 0
    while i < s.length =>
        var code: int = s.charAt(i) as int
        if code < 48 || code > 57 =>
            return result
        result = result * 10 + (code - 48)
        i = i + 1
    return result

# Check if a string contains only digit characters
fn _isNumeric(s: str): bool =>
    if s.length == 0 =>
        return false
    var i: int = 0
    while i < s.length =>
        var ch: char = s.charAt(i)
        var code: int = ch as int
        if code < 48 =>
            return false
        if code > 57 =>
            return false
        i = i + 1
    return true

# Lexicographic string comparison: returns -1, 0, or 1
fn _strcmp(a: str, b: str): int =>
    var minLen: int = a.length
    if b.length < minLen =>
        minLen = b.length
    var i: int = 0
    while i < minLen =>
        var ca: int = a.charAt(i) as int
        var cb: int = b.charAt(i) as int
        if ca < cb =>
            return -1
        if ca > cb =>
            return 1
        i = i + 1
    if a.length < b.length =>
        return -1
    if a.length > b.length =>
        return 1
    return 0

# Compare two prerelease strings according to SemVer 2.0.0 rules
# Expects: both empty or both non-empty (asymmetric cases handled by _versionCmp)
fn _comparePrerelease(a: str, b: str): int =>
    if a == "" && b == "" =>
        return 0

    var partsA: str[] = a.split(".")
    var partsB: str[] = b.split(".")

    // WORKAROUND: Force string element pinning by using them before the loop.
    // Without this, accessing partsA[i] inside the while loop returns empty strings.
    var _lenA: int = partsA[0].length
    var _lenB: int = partsB[0].length

    var minLen: int = partsA.length
    if partsB.length < minLen =>
        minLen = partsB.length

    var i: int = 0
    while i < minLen =>
        var pa: str = partsA[i]
        var pb: str = partsB[i]
        var aIsNum: bool = _isNumeric(pa)
        var bIsNum: bool = _isNumeric(pb)

        if aIsNum =>
            if bIsNum =>
                # Both numeric: compare as integers
                var na: int = _strToInt(pa)
                var nb: int = _strToInt(pb)
                if na < nb =>
                    return -1
                if na > nb =>
                    return 1
            else =>
                # Numeric < Alphanumeric
                return -1
        else =>
            if bIsNum =>
                # Alphanumeric > Numeric
                return 1
            else =>
                # Both alphanumeric: compare lexically
                var cmp: int = _strcmp(pa, pb)
                if cmp != 0 =>
                    return cmp
        i = i + 1

    # All compared identifiers are equal; fewer fields = lower precedence
    if partsA.length < partsB.length =>
        return -1
    if partsA.length > partsB.length =>
        return 1
    return 0


# Parse a version string into a Version
fn _parseVersionString(s: str): Version =>
    var major: int = 0
    var minor: int = 0
    var patch: int = 0
    var prerelease: str = ""
    var build: str = ""

    # Find the build metadata separator '+'
    var plusIdx: int = s.indexOf("+")
    var corePre: str = s
    if plusIdx >= 0 =>
        build = s.substring(plusIdx + 1, s.length)
        corePre = s.substring(0, plusIdx)

    # Find the prerelease separator '-'
    var dashIdx: int = corePre.indexOf("-")
    var core: str = corePre
    if dashIdx >= 0 =>
        prerelease = corePre.substring(dashIdx + 1, corePre.length)
        core = corePre.substring(0, dashIdx)

    # Parse MAJOR.MINOR.PATCH
    var parts: str[] = core.split(".")
    if parts.length >= 1 =>
        major = _strToInt(parts[0])
    if parts.length >= 2 =>
        minor = _strToInt(parts[1])
    if parts.length >= 3 =>
        patch = _strToInt(parts[2])

    var result: Version = Version { major: major, minor: minor, patch: patch, prerelease: prerelease, build: build }
    return result

# Parse a constraint version string
fn _parseConstraintVersion(s: str): Version =>
    var prerelease: str = ""
    var core: str = s

    # Check for prerelease
    var dashIdx: int = s.indexOf("-")
    if dashIdx >= 0 =>
        prerelease = s.substring(dashIdx + 1, s.length)
        core = s.substring(0, dashIdx)

    var parts: str[] = core.split(".")
    var major: int = 0
    var minor: int = 0
    var patch: int = 0
    if parts.length >= 1 =>
        major = _strToInt(parts[0])
    if parts.length >= 2 =>
        minor = _strToInt(parts[1])
    if parts.length >= 3 =>
        patch = _strToInt(parts[2])

    var result: Version = Version { major: major, minor: minor, patch: patch, prerelease: prerelease, build: "" }
    return result

# ==============================================================================
# Convenience Functions
# ==============================================================================

# Parse a constraint string and check if version satisfies it
fn version_satisfies(v: Version, constraint: str): bool =>
    var c: VersionConstraint = VersionConstraint.parse(constraint)
    return c.satisfiedBy(v)

# Check comma-separated constraints (AND logic): ">=1.0.0, <2.0.0"
fn version_satisfies_all(v: Version, constraints: str): bool =>
    var parts: str[] = constraints.split(",")
    var i: int = 0
    while i < parts.length =>
        var part: str = parts[i].trim()
        if part != "" =>
            if !version_satisfies(v, part) =>
                return false
        i = i + 1
    return true
