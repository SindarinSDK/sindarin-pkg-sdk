# ==============================================================================
# sdk/encoding/zlib.sn - Zlib Compression Library for Sindarin
# ==============================================================================
# Provides zlib compression/decompression bindings and high-level wrappers.
#
# Usage:
#   import "sdk/encoding/zlib"
#
#   // High-level API (recommended)
#   var compressed: byte[] = compressData(data)
#   var original: byte[] = decompressData(compressed, originalSize)
#
#   // With compression level (0-9, default 6)
#   var fast: byte[] = compressDataLevel(data, 1)      // Fastest
#   var best: byte[] = compressDataLevel(data, 9)      // Best compression
#
# Requirements:
#   - zlib library must be installed (libz)
#   - Linux: sudo apt install zlib1g-dev
#   - macOS: brew install zlib (usually pre-installed)
#   - Windows: Install zlib via vcpkg or download from zlib.net
# ==============================================================================

@include <zlib.h>
@link z

# ==============================================================================
# Error Codes
# ==============================================================================
# zlib returns these error codes from compression/decompression functions.

fn zlibOk(): int => 0
fn zlibStreamEnd(): int => 1
fn zlibNeedDict(): int => 2
fn zlibErrno(): int => -1
fn zlibStreamError(): int => -2
fn zlibDataError(): int => -3
fn zlibMemError(): int => -4
fn zlibBufError(): int => -5
fn zlibVersionError(): int => -6

# ==============================================================================
# Compression Levels
# ==============================================================================

fn noCompression(): int => 0
fn bestSpeed(): int => 1
fn bestCompression(): int => 9
fn defaultCompression(): int => -1

# ==============================================================================
# Low-Level zlib Bindings
# ==============================================================================
# These are direct bindings to the zlib C library.
# For most use cases, prefer the high-level wrappers below.

# compress2 - Compress with specified level
@alias "compress2"
native fn compress2(dest: *byte, destLen: uint as ref, source: *byte, sourceLen: uint, level: int): int

# compress - Compress with default level
@alias "compress"
native fn compress(dest: *byte, destLen: uint as ref, source: *byte, sourceLen: uint): int

# uncompress - Decompress data
@alias "uncompress"
native fn uncompress(dest: *byte, destLen: uint as ref, source: *byte, sourceLen: uint): int

# compressBound - Calculate upper bound for compressed size
@alias "compressBound"
native fn compressBound(sourceLen: uint): uint

# ==============================================================================
# Error Message Helper
# ==============================================================================

fn errorMessage(code: int): str =>
    if code == zlibOk() =>
        return "OK"
    if code == zlibStreamEnd() =>
        return "Stream end"
    if code == zlibNeedDict() =>
        return "Need dictionary"
    if code == zlibErrno() =>
        return "File error"
    if code == zlibStreamError() =>
        return "Stream error"
    if code == zlibDataError() =>
        return "Data error (corrupted or incomplete)"
    if code == zlibMemError() =>
        return "Memory error"
    if code == zlibBufError() =>
        return "Buffer error (output too small)"
    if code == zlibVersionError() =>
        return "Version error"
    return "Unknown error"

# ==============================================================================
# High-Level Compression API
# ==============================================================================

# compressTo - Compress data into provided buffer
# Returns number of bytes written, or -1 on error
native fn compressTo(source: byte[], dest: byte[]): int =>
    var destLen: uint = dest.length as uint
    var result: int = compress(dest as ref, destLen, source as ref, source.length as uint)
    if result != 0 =>
        return -1
    return destLen as int

# compressToLevel - Compress with specific level into provided buffer
# Returns number of bytes written, or -1 on error
native fn compressToLevel(source: byte[], dest: byte[], level: int): int =>
    var destLen: uint = dest.length as uint
    var result: int = compress2(dest as ref, destLen, source as ref, source.length as uint, level)
    if result != 0 =>
        return -1
    return destLen as int

# decompressTo - Decompress data into provided buffer
# Returns number of bytes written, or -1 on error
native fn decompressTo(source: byte[], dest: byte[]): int =>
    var destLen: uint = dest.length as uint
    var result: int = uncompress(dest as ref, destLen, source as ref, source.length as uint)
    if result != 0 =>
        return -1
    return destLen as int

# maxCompressedSize - Calculate maximum possible compressed size
fn maxCompressedSize(sourceLen: int): int => compressBound(sourceLen as uint) as int

# ==============================================================================
# Convenience Wrappers (allocate output buffer automatically)
# ==============================================================================

# compressData - Compress data with default compression level
# Returns compressed data, or empty array on error
native fn compressData(source: byte[]): byte[] =>
    if source.length == 0 =>
        return source

    var bound: int = maxCompressedSize(source.length)
    var dest: byte[bound]
    var destLen: uint = bound as uint

    var result: int = compress(dest as ref, destLen, source as ref, source.length as uint)
    if result != 0 =>
        var empty: byte[0]
        return empty

    return dest[0..(destLen as int)] as val

# compressDataLevel - Compress data with specified level
# Returns compressed data, or empty array on error
native fn compressDataLevel(source: byte[], level: int): byte[] =>
    if source.length == 0 =>
        return source

    var bound: int = maxCompressedSize(source.length)
    var dest: byte[bound]
    var destLen: uint = bound as uint

    var result: int = compress2(dest as ref, destLen, source as ref, source.length as uint, level)
    if result != 0 =>
        var empty: byte[0]
        return empty

    return dest[0..(destLen as int)] as val

# decompressData - Decompress data
# expectedSize: the size of the original uncompressed data
# Returns decompressed data, or empty array on error
native fn decompressData(source: byte[], expectedSize: int): byte[] =>
    if source.length == 0 =>
        return source

    var dest: byte[expectedSize]
    var destLen: uint = expectedSize as uint

    var result: int = uncompress(dest as ref, destLen, source as ref, source.length as uint)
    if result != 0 =>
        var empty: byte[0]
        return empty

    return dest[0..(destLen as int)] as val

# ==============================================================================
# Utility Functions
# ==============================================================================

# isCompressed - Simple heuristic to check if data might be zlib-compressed
fn isCompressed(data: byte[]): bool =>
    if data.length < 2 =>
        return false

    # zlib header: first byte is CMF (usually 0x78 for deflate)
    var cmf: int = data[0]
    var flg: int = data[1]

    # Common zlib headers: 78 01, 78 5E, 78 9C, 78 DA
    if cmf != 120 =>
        return false

    var check: int = cmf * 256 + flg
    return check % 31 == 0

# compressionRatio - Calculate compression ratio
# Returns ratio as percentage (e.g., 75.5 means compressed to 75.5% of original)
fn compressionRatio(originalSize: int, compressedSize: int): double =>
    if originalSize == 0 =>
        return 0.0
    return (compressedSize as double * 100.0) / (originalSize as double)

# spaceSaved - Calculate space saved by compression
# Returns percentage saved (e.g., 24.5 means saved 24.5% of original size)
fn spaceSaved(originalSize: int, compressedSize: int): double => 100.0 - compressionRatio(originalSize, compressedSize)
